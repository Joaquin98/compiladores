IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__x0"], 
irDeclBody = IrBinaryOp Add (IrVar "__x0") (IrConst (CNat 1))}

IrVal {irDeclName = "f", irDeclDef = MkClosure "__1" []}

IrVal {irDeclName = "z", irDeclDef = IrLet "__e3" (IrVar "f") (IrCall (IrAccess (IrVar "__e3") 0)
 [IrVar "__e3",IrConst (CNat 1)])}

IrFun {irDeclName = "__5", irDeclArity = 2, irDeclArgNames = ["__clo6","__x4"], 
irDeclBody = IrLet "__y7" (IrConst (CNat 45)) 
(IrLet "__e8" (IrVar "f") (IrCall (IrAccess (IrVar "__e8") 0) [IrVar "__e8",IrVar "__x4"]))}

IrVal {irDeclName = "g", irDeclDef = MkClosure "__5" []}


-------------------------------------------------


IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__x0"], irDeclBody = IrBinaryOp Add (IrVar "__x0") (IrConst (CNat 1))}
IrVal {irDeclName = "f", irDeclDef = MkClosure "__1" []}
IrVal {irDeclName = "z", irDeclDef = IrLet "__e3" (IrVar "f") (IrCall (IrAccess (IrVar "__e3") 0) [IrVar "__e3",IrConst (CNat 1)])}
IrFun {irDeclName = "__5", irDeclArity = 2, irDeclArgNames = ["__clo6","__x4"], irDeclBody = IrLet "__y7" (IrConst (CNat 45)) (IrLet "__e8" (IrVar "f") (IrCall (IrAccess (IrVar "__e8") 0) [IrVar "__e8",IrVar "__x4"]))}
IrVal {irDeclName = "g", irDeclDef = MkClosure "__5" []}


IrFun {irDeclName = "__14", irDeclArity = 2, irDeclArgNames = ["__clo15","__y13"], 
irDeclBody = IrLet "__suma12" (IrAccess (IrVar "__clo15") 1) (IrLet "__x9" (IrAccess (IrVar "__clo15") 2)
 (IrIfZ (IrVar "__x9") (IrVar "__y13") (IrLet "__e17" (IrLet "__e16" (IrVar "__suma12") 
 (IrCall (IrAccess (IrVar "__e16") 0) [IrVar "__e16",IrBinaryOp Diff (IrVar "__x9") (IrConst (CNat 1))])) 
 (IrCall (IrAccess (IrVar "__e17") 0) [IrVar "__e17",IrBinaryOp Add (IrVar "__y13") (IrConst (CNat 1))]))))}
IrFun {irDeclName = "__10", irDeclArity = 2, irDeclArgNames = ["__clo11","__x9"], 
irDeclBody = IrLet "__suma12" (IrVar "__clo11") (MkClosure "__14" [IrVar "__suma12",IrVar "__x9"])}
IrVal {irDeclName = "suma", irDeclDef = MkClosure "__10" []}



IrVal {irDeclName = "res", irDeclDef = IrLet "__e19" (IrLet "__e18" (IrVar "suma") (IrCall (IrAccess (IrVar "__e18") 0) [IrVar "__e18",IrConst (CNat 3)])) (IrCall (IrAccess (IrVar "__e19") 0) [IrVar "__e19",IrVar "z"])}

--------------------------------------------------

IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__x0"], 
irDeclBody = IrLet "__fib3" (IrVar "__clo2") (IrIfZ (IrVar "__x0") (IrConst (CNat 1)) 
(IrIfZ (IrBinaryOp Diff (IrVar "__x0") (IrConst (CNat 1))) (IrConst (CNat 1)) 


(IrBinaryOp Add (IrLet "__e4" (IrVar "__fib3") 
(IrCall (IrAccess (IrVar "__e4") 0) [IrVar "__e4",IrBinaryOp Diff (IrVar "__x0") (IrConst (CNat 1))]))
(IrLet "__e5" (IrVar "__fib3") 
(IrCall (IrAccess (IrVar "__e5") 0) [IrVar "__e5",IrBinaryOp Diff (IrBinaryOp Diff (IrVar "__x0") 
(IrConst (CNat 1))) (IrConst (CNat 1))])))))}

(fib (pred x)) + (fib (pred (pred x))))

let rec fib(x:Nat):Nat = ifz x then 1 else 
(ifz pred x then 1 else  (fib (pred x)) + (fib (pred (pred x))))


Error del free
Constructor Print LLVM
Producto


Hola Mauro, estabamos intentando terminar la compilación a código LLVM
y nos surguieron algunas dudas:

- En el módulo InstSel aparece una operación binaria para el producto
(Prod) tendríamos que agregarla a nuestro lenguaje?

- Logramos compilar a llvm y correr algunos programas, pero no sabemos 
 como hacer para ver el valor de retorno de nuestros programas. Vimos que
 en el mismo módulo está la operación unaria Print y pensamos que tal vez
 se podría utilizar para printear el valor de la última declaración. 
 Habría que agregar la función print a nuestro lenguaje o solo agregarla 
 al lenguaje intermedio y aplicarsela a la última declaración? O hay alguna
  otra forma de saber el valor de retorno?

- Estamos teniendo problemas al compilar una función recursiva que tienen 
  en su definición dos llamadas a si misma, como es el caso de fibonacci:

    let rec fib(x:Nat):Nat = ifz x then 1 else 
    (ifz pred x then 1 else  (fib (pred x)) + (fib (pred (pred x))))

Cuando la ejecutamos nos tira un error: "free(): invalid pointer"

Queríamos saber si nos podrías dar consulta o guiarnos un poco por escrito.

Gracias!

--------------------------------------------------------------------------------

- El lenguaje antes al hacer una resta (a-b) si b > a entonces retornaba 0.
Ahora al compilar a llvm cuando se hace una resta puede retornar un número 
negativo.

- El tamaño para expandir.

- Están mas o menos bien las optimizaciones.

- Orden opt, cantidad.

- Captura de variables.

- Búsqueda eficiente de las expresiones iguales.