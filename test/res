IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__x0"], 
irDeclBody = IrBinaryOp Add (IrVar "__x0") (IrConst (CNat 1))}

IrVal {irDeclName = "f", irDeclDef = MkClosure "__1" []}

IrVal {irDeclName = "z", irDeclDef = IrLet "__e3" (IrVar "f") (IrCall (IrAccess (IrVar "__e3") 0)
 [IrVar "__e3",IrConst (CNat 1)])}

IrFun {irDeclName = "__5", irDeclArity = 2, irDeclArgNames = ["__clo6","__x4"], 
irDeclBody = IrLet "__y7" (IrConst (CNat 45)) 
(IrLet "__e8" (IrVar "f") (IrCall (IrAccess (IrVar "__e8") 0) [IrVar "__e8",IrVar "__x4"]))}

IrVal {irDeclName = "g", irDeclDef = MkClosure "__5" []}


-------------------------------------------------


IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__x0"], irDeclBody = IrBinaryOp Add (IrVar "__x0") (IrConst (CNat 1))}
IrVal {irDeclName = "f", irDeclDef = MkClosure "__1" []}
IrVal {irDeclName = "z", irDeclDef = IrLet "__e3" (IrVar "f") (IrCall (IrAccess (IrVar "__e3") 0) [IrVar "__e3",IrConst (CNat 1)])}
IrFun {irDeclName = "__5", irDeclArity = 2, irDeclArgNames = ["__clo6","__x4"], irDeclBody = IrLet "__y7" (IrConst (CNat 45)) (IrLet "__e8" (IrVar "f") (IrCall (IrAccess (IrVar "__e8") 0) [IrVar "__e8",IrVar "__x4"]))}
IrVal {irDeclName = "g", irDeclDef = MkClosure "__5" []}


IrFun {irDeclName = "__14", irDeclArity = 2, irDeclArgNames = ["__clo15","__y13"], 
irDeclBody = IrLet "__suma12" (IrAccess (IrVar "__clo15") 1) (IrLet "__x9" (IrAccess (IrVar "__clo15") 2)
 (IrIfZ (IrVar "__x9") (IrVar "__y13") (IrLet "__e17" (IrLet "__e16" (IrVar "__suma12") 
 (IrCall (IrAccess (IrVar "__e16") 0) [IrVar "__e16",IrBinaryOp Diff (IrVar "__x9") (IrConst (CNat 1))])) 
 (IrCall (IrAccess (IrVar "__e17") 0) [IrVar "__e17",IrBinaryOp Add (IrVar "__y13") (IrConst (CNat 1))]))))}
IrFun {irDeclName = "__10", irDeclArity = 2, irDeclArgNames = ["__clo11","__x9"], 
irDeclBody = IrLet "__suma12" (IrVar "__clo11") (MkClosure "__14" [IrVar "__suma12",IrVar "__x9"])}
IrVal {irDeclName = "suma", irDeclDef = MkClosure "__10" []}



IrVal {irDeclName = "res", irDeclDef = IrLet "__e19" (IrLet "__e18" (IrVar "suma") (IrCall (IrAccess (IrVar "__e18") 0) [IrVar "__e18",IrConst (CNat 3)])) (IrCall (IrAccess (IrVar "__e19") 0) [IrVar "__e19",IrVar "z"])}

--------------------------------------------------

IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__x0"], 
irDeclBody = IrLet "__fib3" (IrVar "__clo2") (IrIfZ (IrVar "__x0") (IrConst (CNat 1)) 
(IrIfZ (IrBinaryOp Diff (IrVar "__x0") (IrConst (CNat 1))) (IrConst (CNat 1)) 


(IrBinaryOp Add (IrLet "__e4" (IrVar "__fib3") 
(IrCall (IrAccess (IrVar "__e4") 0) [IrVar "__e4",IrBinaryOp Diff (IrVar "__x0") (IrConst (CNat 1))]))
(IrLet "__e5" (IrVar "__fib3") 
(IrCall (IrAccess (IrVar "__e5") 0) [IrVar "__e5",IrBinaryOp Diff (IrBinaryOp Diff (IrVar "__x0") 
(IrConst (CNat 1))) (IrConst (CNat 1))])))))}

(fib (pred x)) + (fib (pred (pred x))))

let rec fib(x:Nat):Nat = ifz x then 1 else 
(ifz pred x then 1 else  (fib (pred x)) + (fib (pred (pred x))))


Error del free
Constructor Print LLVM
Producto


Hola Mauro, estabamos intentando terminar la compilación a código LLVM
y nos surguieron algunas dudas:

- En el módulo InstSel aparece una operación binaria para el producto
(Prod) tendríamos que agregarla a nuestro lenguaje?

- Logramos compilar a llvm y correr algunos programas, pero no sabemos 
 como hacer para ver el valor de retorno de nuestros programas. Vimos que
 en el mismo módulo está la operación unaria Print y pensamos que tal vez
 se podría utilizar para printear el valor de la última declaración. 
 Habría que agregar la función print a nuestro lenguaje o solo agregarla 
 al lenguaje intermedio y aplicarsela a la última declaración? O hay alguna
  otra forma de saber el valor de retorno?

- Estamos teniendo problemas al compilar una función recursiva que tienen 
  en su definición dos llamadas a si misma, como es el caso de fibonacci:

    let rec fib(x:Nat):Nat = ifz x then 1 else 
    (ifz pred x then 1 else  (fib (pred x)) + (fib (pred (pred x))))

Cuando la ejecutamos nos tira un error: "free(): invalid pointer"

Queríamos saber si nos podrías dar consulta o guiarnos un poco por escrito.

Gracias!

--------------------------------------------------------------------------------

- El lenguaje antes al hacer una resta (a-b) si b > a entonces retornaba 0.
Ahora al compilar a llvm cuando se hace una resta puede retornar un número 
negativo.

- El tamaño para expandir.

- Están mas o menos bien las optimizaciones.

- Orden opt, cantidad.

- Captura de variables.

- Búsqueda eficiente de las expresiones iguales.

[Decl  declName = "z", declType = NatTy, declBody = App (V (Free "f")) (Const  (CNat 1))},
Decl  declName = "f", declType = FunTy NatTy NatTy, declBody = Lam  "x" NatTy (BinaryOp  Add (V (Bound 0)) (Const (CNat 1)))}]


[Decl {declPos = (63,1), declName = "res6", declType = NatTy, declBody = App (63,16) (Fix (15,1) "mult" (FunTy (NTy "N" NatTy) (FunTy (NTy "N" NatTy) NatTy)) "x" (NTy "N" NatTy) (Lam (15,1) "y" (NTy "N" NatTy) (IfZ (15,28) (V (15,34) (Bound 0)) (Const (15,41) (CNat 0)) (BinaryOp (15,46) Add (V (15,48) (Bound 1)) (App (15,51) (App (15,51) (V (15,56) (Bound 2)) (V (15,58) (Bound 1))) (BinaryOp (15,59) Diff (V (15,65) (Bound 0)) (Const (15,59) (CNat 1)))))))) (Const (71,38) (CNat 5))}]


let suma (x y:Nat):Nat = x + y 
let resta (x y:Nat):Nat = x - y

let ans:Nat = suma (resta 5 4) 1

declName = "ans", declBody = App  (LetIn  "linexp0" NatTy (App  (LetIn  "linexp1" NatTy (Const 5) 
(Lam "y" NatTy (BinaryOp Diff (V (Bound 1)) (V (Bound 0))))) (Const 4))) 
(Lam  "y" NatTy (BinaryOp Add (V  (Bound 1)) (V  (Bound 0))))) (Const 1))}]

let linexp0= ((let linexp1=5 in (\y -> linexp1 - y)) 4) in (\y -> linexp0 + 1)

[Decl {declPos = (44,1), declName = "ans", declType = NatTy, declBody = App (44,15) (LetIn  "linexp0" NatTy (App (44,21) (LetIn  "linexp0" NatTy (Const (44,29) (CNat 5)) (Lam (42,1) "y" NatTy (BinaryOp (42,27) Diff (V (42,29) (Bound 1)) (V (44,1) (Bound 0))))) (Const (44,30) (CNat 4))) (Lam (41,1) "y" NatTy (BinaryOp (41,26) Add (V (41,28) (Bound 1)) (V (42,1) (Bound 0))))) (Co


[Decl {declPos = (46,1), declName = "x", declType = NatTy, declBody = LetIn  "linexp0" NatTy  (CNat 3) (BinaryOp (46,28) Add (V (46,30) (Bound 0)) (Const (46,33) (CNat 2)))}]


[Decl {declPos = (44,1), declName = "ans", declType = NatTy, declBody = App (44,15) 
(LetIn  "linexp0" NatTy (App  (Lam "x" NatTy (Lam "y" NatTy 
(BinaryOp  Diff  (Bound 1) (Bound 0))) (Const 4)) (Lam "y" NatTy (BinaryOp Add (Bound 1) (Bound 0))) 1)}]


(App (Let linexp0 
(App (Lam (Lam (Diff (Bound 1) (Bound 0)))) (4))
(Lam (Add (Bound 1) (Bound 0))))
 (1))

(let linexp0 = (\x -> (\y -> x - y))  4 in (\x -> linexp0' + x)) 1
(let linexp0 = (\y -> 4 - y) in (\x -> linexp0' + x)) 1


(Lam (Add (1) (Bound 0)))

(Lam (Lam (Add (Bound 1) (Bound 0))))
(4)
(App (App (Free "suma") (Free "z1")) (1))