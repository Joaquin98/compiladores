Cosas que se pueden agregar:

- Comando para resetear las funciones que fueron cargadas (:r) para evitar
  tener que ejecutar el main cada vez que se agrega una nueva fución.

- Comando para cargar todos los archivos .pcf que hayan en test.

Posibles errores:

- try en el unaryOp
El try siempre vuelve atras lo consumido por un 
parser que terminó en error, en cambio el <|> solo
ejecuta el siguiente en caso que el primer intento
no haya consumido ningun texto.

- parserZero en letRec
ParserZero es un parser que falla siempre sin consumir 
nada.

- La funciones existentes de los tipos en el entorno 
global no eran para usar con los sinonimos de tipos
sino que eran para ir guardando en tipo de cada variable
declarada en un let para usarlos luego en el typeChecker.


Consultas:

- Fix con muchos argumentos. Porque en la parte de implementacion dice que 
SFix tiene [(Name, Ty)]. Como queramos.

(Mostrar y explicar como fuimos haciendo todo)
- Muchos tipos distintos, uno para cada paso de conversión (multibinding, nombres de tipos,
                                                            desugaring)
                                                            
- Conversion de los tipos nombre a tipos iria en el main (en el elab no se puede x el entorno)                                                            

- Donde convertir las declaraciones? Nuevo modulo?

5/10:
- Que hacemos con el tipo NTy en el caso que SFunTy (NType "y" SNat) (SNat).
  En el caso que no le pongamos nombre a los SFunTy perdemos los nombre de adentro.
  Y si usamos un arbol cambiria mucho todo.

- Nombre KArg en ([] t) por que?

- Se podria guardar el termino completo detro de CFun o CFix? Ya que no cambiria ?.


22/10:
- eq en tipos? no deberian estar resueltos del todo? es la idea?

- que es Module? que pasa con las declaraciones type?

- esta bien el ifz?

- ejemplos conflictivos que podrian romper lo ya hecho? (CEK sobre todo)



02/11:

- DIFF y ADD o solo ADD?
Está bien que estén ambas funciones.
- Pregunta de reemplazo.
No es posible hacerlo tan simple porque el 5 representa la llamada CALL
pero también podría ser el indice del ACCESS. Con lo cual se podría hacer 
pero analizando bien el código. Otro problema que puede generar es que 
por ejemplo la función tiene la longitud de su código al reemplazar 2 
instrucciones por 1 la longitud de la función sería incorrecta.
- Mostrar y pedir ejemplo.
La memoria sigue siendo mucha incluso en el caso del TAILCALL porque 
en la lista del entorno no se libera la memoria.

16/11:

- Term -> IrTm: Que pasa con el nombre de las variables, porque el 
Term tiene índices y IrTm necesita de FullyNames.

- Que devuelve [[f]] es la lista de [IrDecl] u otra cosa?

- StateT Int: Se lleva la cuenta de los nombres de variables frescos
dentro de un term, pero cuando se pasa a otro se pierde?



19/11:

IrVal {irDeclName = "x", irDeclDef = IrConst (CNat 1)}
IrVal {irDeclName = "y", irDeclDef = IrBinaryOp Add (IrConst (CNat 2)) (IrVar "x")}
IrFun {irDeclName = "__1", irDeclArity = 2, irDeclArgNames = ["__clo2","__y0"], irDeclBody = IrBinaryOp Add (IrConst (CNat 1)) (IrVar "x")}
IrVal {irDeclName = "f", irDeclDef = MkClosure "__1" []}
IrFun {irDeclName = "__7", irDeclArity = 2, irDeclArgNames = ["__clo8","__y6"], irDeclBody = IrLet "__x3" (IrAccess (IrVar "__clo8") 1) (IrBinaryOp Add (IrVar "__x3") (IrVar "__y6"))}
IrFun {irDeclName = "__4", irDeclArity = 2, irDeclArgNames = ["__clo5","__x3"], irDeclBody = MkClosure "__7" [IrVar "__x3"]}
IrVal {irDeclName = "suma", irDeclDef = MkClosure "__4" []}
IrVal {irDeclName = "suma5", irDeclDef = IrLet "__e9" (IrVar "suma") (IrCall (IrAccess (IrVar "__e9") 0) [IrVar "__e9",IrConst (CNat 5)])}
IrFun {irDeclName = "__11", irDeclArity = 2, irDeclArgNames = ["__clo12","__n10"], irDeclBody = IrLet "__countdown13" (IrVar "__clo12") (IrIfZ (IrVar "__n10") (IrConst (CNat 0)) (IrLet "__e14" (IrVar "__countdown13") (IrCall (IrAccess (IrVar "__e14") 0) [IrVar "__e14",IrBinaryOp Diff (IrVar "__n10") (IrConst (CNat 1))])))}
IrVal {irDeclName = "countdown", irDeclDef = MkClosure "__11" []}



- Puede ser que en el ejemplo no se agregue el let (regla de aplicacion)??
- Esta bien el Fix? 
- Cuando usaríamos esta conversión para poder probar mejor?



- Donde hacer el reemplazo de tipos:
-- En el handleDecl en el main (STm que tome parametro para los tipos y hacer la conversion).
Tomamos Type n = t como una declaración. Una declaración puede ser tanto un let como un type 
(Either TDecl, TTDecl).
-- Parsear directamente a STm. No sabemos como se haría para llevar un estado (que realcione 
nombre de tipos con tipos) mientras parseamos.



